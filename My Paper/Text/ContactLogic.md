# 碰撞检测逻辑模块

## 碰撞检测的简介
碰撞侦测(Collision detection)或称为碰撞检测通常是指一种判断两个或多个对象是否产生交集的的方法,往往应用于电子游戏和其他计算物理学当中,也应用于人工智能当中.除了确定两个对象是否已经碰撞, 碰撞侦测也可以用于计算冲击的时间(TOI),以及回报对象交叉的位置,碰撞响应一旦侦测到碰撞则处理模拟(物理引擎，布娃娃系统),解决碰撞侦测问题需要使用广泛的概念,如线性代数和计算几何.
[引用维基百科]

## 本游戏的碰撞检测
作为一个2D 游戏, 并且在不涉及到复杂的物理模型情况下
(比如计算摩擦力,弹性系数,力矩等复杂物理参数)
我们采用基本的 AABB 盒的检测方式.也叫包围体的检测方式.

在碰撞检测中,如果两个包围体没有相交,那么所包含的物体也就不会碰撞.反之,如果两个元素的包围体发生了相交,我们就可以说两个物体发生了碰撞.

## AABB 盒检测的好处
由于包围体的几何形状较为简单,而物体通常是多边形或者简化为多边形近似的数据结构所组成,所以对于包围体的检验通常要比对于物体本身的检验速度更快.在其中任一种场合下,如果物体不可见的话，那么根据视体对每个多边形的检验都是无用的计算.不管物体表面是否真的可见,屏幕上的物体必须裁剪到屏幕能够显示的区域.
[引用维基百科]

## 碰撞逻辑的概要设计
在设计的雷霆战机游戏中,需要进行三个方面的逻辑设计
1. 碰撞过滤:碰撞是否发生,即如何检测有用的碰撞,忽略掉不必要的碰撞,称为碰撞过滤.
2. 碰撞归类:发生碰撞的过程有多个,不同的碰撞过程我们要采取不同的处理策略,这一步要识别碰撞的过程属于哪一类,称为碰撞归类.
3. 碰撞处理:根据碰撞归类的结果,需要采取不同的游戏逻辑来进行处理,部分还需要调用场景切换.称为碰撞处理,

## 碰撞过滤设计
需要处理的碰撞一共有三种
1. 敌机与玩家战机发生碰撞.
2. 敌机子弹与玩家战机发生碰撞.
3. 玩家子弹与敌机发生碰撞.
除此之外的碰撞事件,比如敌机与敌机碰撞,敌机子弹与敌机发生碰撞等,我们默认碰撞没有发生,即是默认这些元素可以发生重叠.

[碰撞逻辑图]

当场景中同时发生了多个碰撞事件,则按照1,2,3的不同的优先级进行顺序处理,先处理序号小的比较重要的事件,然后在处理序号大的次重要事件,但是某些游戏逻辑可能对于场景中的游戏元素做了移除操作,因此必须进行碰撞对象的判空操作,以防碰撞事件的对象已经在上次碰撞处理中被移除,造成野指针的异常.

对于检测到的碰撞,将会获取碰撞中被检测到的碰撞对象,并将其传递到下一步碰撞分类当中.

## 碰撞分类设计
根据模型设计,碰撞处理一共涉及到四种对象:敌机,敌机子弹,玩家子弹,玩家战机.

为了便于碰撞检测的归类,我将不同的对象类分配一个唯一的标识符,标识符使用一个四位的二进制串来表示:
分配情况如下
1. 敌机 0b0001
2. 敌机子弹 0b0010
3. 玩家子弹 0b0100
4. 玩家战机 0b1000

这样分配的好处之一是,进行碰撞归类时,只需要将获取到的两个碰撞对象的标识符执行或运算,就可以了解是哪一种碰撞类型,公式表示如下:

[碰撞分类公式]

根据碰撞过滤的设计,一共需要处理的碰撞事件有:
1. 敌机与玩家战机发生碰撞,执行或运算后的运算结果为0b0101.
2. 敌机子弹与玩家战机发生碰撞,执行或运算后的运算结果为0b0110.
3. 玩家子弹与敌机发生碰撞,执行或运算后的运算结构为0b1001.

分配的好处之二是,碰撞检测机制仅仅只能获取碰撞的对象,也就是说获取的对象指针是四种模型的基类指针,
但是我们在后续的游戏处理逻辑中,需要对不同的对象执行不同的操作,也就是说我们需要进行多态的处理,
这样可能会导致 C++ 运行时崩溃,比如在玩家子弹与敌机碰撞的事件中,如果将敌机指针指向了子弹对象,
游戏逻辑中需要调用敌机的 Alive 方法来判定敌机是否存活,但是子弹并没有实现这一方法,就会导致崩溃.

有了明确的类标识符,我们就可以通过不同的标识符来进行安全的转型.伪代码实现如下:
```
TypeA * a = ((ATag == 0b0100) ? (TypeA *)nodeA : (TypeA *)nodeB);
TypeB * b = ((BTag == 0b0001) ? (TypeB *)nodeA : (TypeB *)nodeB);
```

[流程图]

在以上的过程中,我们判定了不同的碰撞事件,