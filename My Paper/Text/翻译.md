#include <stdlib.h>
#include <math.h>

inline int round (const float a)  
{ 
    return int (a + 0.5); 
}

void lineDDA (int x0, int y0, int xEnd, int yEnd)
{
    int dx=xEnd-x0, dy=yEnd-y0, steps, k; 
    float xIncrement, yIncrement, x = x0, y = y0;
    if (fabs (dx) > fabs (dy))
        steps = fabs (dx);
    else
        steps = fabs (dy);
    
    xIncrement = float (dx) / float (steps);
    yIncrement = float (dy) / float (steps);
    setPixel (round (x), round (y));
    
    for (k = 0; k < steps; k++) 
    {
        x += xIncrement;
        y += yIncrement;
        setPixel (round (x), round (y));
    } 
}

DDA方法计算像素位置要比直接使用直线方程(6.1)计算的速度更快。它利用光撖特性消 除了直线方程(6.1)中的乘法,而在^或y方向使用合适的增量,从而沿线路径逐步得到各像素
的位置。但在浮点增量的连续叠加中,取整误差的积累使得对于较长线段所计算的像素位置偏 离实际线段。而且该过程中的取整操作和浮点运算仍然十分耗时。我们可以通过将增量m和 分离成整数和小数部分,从而使所有的计算都简化为整数操作来改善DDA算法的性能。在6.1〇节
将讨论用整数步长计算1/m增量的方法。在下一节中,我们考虑既能用于直线又能用于曲线的 更通用的扫描线程序。